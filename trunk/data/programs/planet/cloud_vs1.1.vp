
#define outCloudCoord gl_TexCoord[0]
#define outGroundCoord gl_TexCoord[1]
#define outShadowCoord gl_TexCoord[2]
#define outNoiseCoord gl_TexCoord[3]
#define outCityCoord gl_TexCoord[4]

varying vec3 varTSLight;
varying vec3 varTSView;
varying vec3 varWSNormal;

uniform vec4 fGroundContrast_SelfShadowFactor_MinMaxScatterFactor;

#define fGroundContrast fGroundContrast_SelfShadowFactor_MinMaxScatterFactor.x
#define fSelfShadowFactor fGroundContrast_SelfShadowFactor_MinMaxScatterFactor.y
#define fMaxScatterFactor fGroundContrast_SelfShadowFactor_MinMaxScatterFactor.z
#define fMinScatterFactor fGroundContrast_SelfShadowFactor_MinMaxScatterFactor.w

uniform vec4 fAtmosphereType_Thickness_Contrast_LAOffs; 
    //type indexes the t coordinate on cosAngleToDepth, cosAngleToAbsorption, cosAngleToScatter
    //thickness scales cosAngleToDepth
    //contrast is a lighting parameter

#define fAtmosphereType fAtmosphereType_Thickness_Contrast_LAOffs.x
#define fAtmosphereThickness fAtmosphereType_Thickness_Contrast_LAOffs.y
#define fAtmosphereContrast fAtmosphereType_Thickness_Contrast_LAOffs.z
#define fAtmosphereAbsorptionOffset fAtmosphereType_Thickness_Contrast_LAOffs.w

uniform vec4 fAtmosphereExtrusion;
uniform vec4 fShadowRelHeight;

uniform vec4 fvCityLightColor;
uniform vec4 fCityLightTriggerBias;
uniform vec4 fFresnelEffect;

uniform vec4 fAtmosphereAbsorptionColor;
uniform vec4 fAtmosphereScatterColor;

uniform vec4 fReyleighRate_Amount;

#define fReyleighRate fReyleighRate_Amount.x
#define fReyleighAmount fReyleighRate_Amount.y

uniform vec4 fvCloudSelfShadowColor;
uniform vec4 fvCloudColor;
uniform vec4 fvCloudLayerDrift;
uniform vec4 fvCloudLayerMix;
uniform vec4 fvCityLightCloudDiffusion;

uniform vec4 fCloud_Dens_Thick_CLF_SSF;

#define fCloudLayerDensity      fCloud_Dens_Thick_CLF_SSF.x
#define fCloudLayerThickness    fCloud_Dens_Thick_CLF_SSF.y
#define fCityLightFactor        fCloud_Dens_Thick_CLF_SSF.z
#define fCloudSelfShadowFactor  fCloud_Dens_Thick_CLF_SSF.w

uniform float fTime;

uniform vec4 light_size[gl_MaxLights];


float soffs(float lim, float x)
{
  return x + ((x>=0.0)?lim:-lim);
}

vec2 shadowExtrude(in vec2 texcoord, in vec3 direction, float mult)
{
  return texcoord + direction.xy * fAtmosphereExtrusion.x * fShadowRelHeight.x / soffs(0.01,direction.z) * mult;
}

vec4 lightPosAndSize0(in vec4 vertex)
{
  vec4 lpos = gl_LightSource[0].position;
  vec4 rv;
  rv.xyz    = lpos.xyz - vertex.xyz*lpos.w;
  rv.w      = light_size[0].z;
  return rv;
}

float lightAtt0(in vec4 lightpos)
{
  float t = length(lightpos);
  return 1.0 / dot( vec3(1.0,t,t*t),
                    vec3(gl_LightSource[0].constantAttenuation,
                         gl_LightSource[0].linearAttenuation,
                         gl_LightSource[0].quadraticAttenuation) );
}

void main()
{
   // Compute position, eye-to-object direction and normalized world-space normal
   vec4 extrudedPosition = gl_Vertex + vec4(normalize(gl_Normal.xyz),0) * fAtmosphereExtrusion.x * fShadowRelHeight.x;
   vec3 normal   = normalize(gl_NormalMatrix * gl_Normal);
   vec3 tangent  = normalize(gl_NormalMatrix * gl_MultiTexCoord2.xyz);
   vec3 binormal = cross(tangent, normal) * sign(gl_MultiTexCoord2.w);
   
   // Extrude sphere
   vec4 position = gl_ModelViewMatrix * extrudedPosition;
   
   vec3 eyetopos = normalize(position.xyz);
   vec4 rlightpos = lightPosAndSize0(position);
   vec4 lightpos = normalize(rlightpos);
   
   // TS view vector
   varTSView.x = dot( tangent, -eyetopos );
   varTSView.y = dot( binormal, -eyetopos );
   varTSView.z = dot( normal, -eyetopos );
   
   // TS light posision
   varTSLight.x = dot( tangent, lightpos.xyz );
   varTSLight.y = dot( binormal, lightpos.xyz );
   varTSLight.z = dot( normal, lightpos.xyz );
   
   // WS normal
   varWSNormal = normal;
   
   // Load varyings
   outCloudCoord       = gl_MultiTexCoord0 + fTime*fvCloudLayerDrift.xyxy;
   outNoiseCoord       = gl_MultiTexCoord0 - fTime*fvCloudLayerDrift.xyxy;
   outCityCoord        = gl_MultiTexCoord0;
   outGroundCoord      = shadowExtrude(outCloudCoord.xy, varTSView, 1.0).xyxy;
   outShadowCoord      = shadowExtrude(outGroundCoord.xy, varTSLight, -1.0).xyxy;
   
   // set primary color to the emissive material properties
   vec4 pc = gl_FrontMaterial.emission;
   vec4 sc = vec4(0.0);
   pc.a = fvCloudColor.a * fCloudLayerDensity;
   
   float att = lightAtt0(rlightpos);
   pc.rgb += fvCloudColor.rgb * gl_LightSource[0].diffuse.rgb * att;
   sc.rgb += fvCloudColor.rgb * gl_LightSource[0].specular.rgb * att;
   
   // Need this instead of ftransform() for invariance
   gl_Position = gl_ModelViewProjectionMatrix * extrudedPosition;
   gl_FrontColor = gl_BackColor = pc;
   gl_FrontSecondaryColor = gl_BackSecondaryColor = sc;
}



