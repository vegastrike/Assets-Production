uniform vec4 envColor;
uniform float fTime;
uniform vec4 fAtmosphereExtrusion;
uniform vec4 fvCloudLayerDrift_ShadowRelHeight;
uniform vec4 fCloud_Dens_Thick_CLF_SSF;

uniform vec4 light_size[gl_MaxLights];

varying vec3 varTSLight;
varying vec3 varTSView;


float soffs(float lim, float x)
{
  return x + ((x>=0.0)?lim:-lim);
}

vec2 shadowExtrude(in vec2 texcoord, in vec3 direction)
{
  return texcoord - direction.xy * fAtmosphereExtrusion.x * fvCloudLayerDrift_ShadowRelHeight.w / soffs(0.01,direction.z);
}

vec4 lightPosAndSize0(in vec4 vertex)
{
  vec4 lpos = gl_LightSource[0].position;
  vec4 rv;
  rv.xyz    = lpos.xyz - vertex.xyz*lpos.w;
  rv.w      = light_size[0].z;
  return rv;
}

float lightAtt0(in vec4 lightpos)
{
  float t = length(lightpos);
  return 1.0 / dot( vec3(1.0,t,t*t),
                    vec3(gl_LightSource[0].constantAttenuation,
                         gl_LightSource[0].linearAttenuation,
                         gl_LightSource[0].quadraticAttenuation) );
}

void main() 
{
  // Compute position, eye-to-object direction and normalized world-space normal
  vec4 position = gl_ModelViewMatrix * gl_Vertex;
  vec3 eyetopos = normalize(position.xyz);
  vec3 normal   = normalize(gl_NormalMatrix * gl_Normal);
  vec3 tangent  = normalize(gl_NormalMatrix * gl_MultiTexCoord2.xyz);
  vec3 binormal = cross(tangent, normal) * sign(gl_MultiTexCoord2.w);
  vec4 rlightpos = lightPosAndSize0(position);
  vec4 lightpos = normalize(rlightpos);
  
  // Load varyings
  gl_TexCoord[0] = gl_MultiTexCoord0;
  
  // TS view vector
  varTSView.x = dot( tangent, -eyetopos );
  varTSView.y = dot( binormal, -eyetopos );
  varTSView.z = dot( normal, -eyetopos );
  
  // TS light posision
  varTSLight.x = dot( tangent, lightpos.xyz );
  varTSLight.y = dot( binormal, lightpos.xyz );
  varTSLight.z = dot( normal, lightpos.xyz );
  
  // Cloud & shadow coords
  gl_TexCoord[1].zw = gl_MultiTexCoord0.xy + fTime*fvCloudLayerDrift_ShadowRelHeight.xy;
  gl_TexCoord[1].xy = shadowExtrude(gl_TexCoord[1].zw, varTSLight);
  gl_TexCoord[2].xy = shadowExtrude(gl_MultiTexCoord0.xy - fTime*fvCloudLayerDrift_ShadowRelHeight.xy, varTSLight);
  gl_TexCoord[2].zw = vec2(0.0);
  
  // set primary color to the emissive material properties
  vec4 pc = gl_FrontMaterial.emission;
  vec4 sc = vec4(0.0);
  
  float att = lightAtt0(rlightpos);
  pc += gl_FrontMaterial.diffuse * gl_LightSource[0].diffuse;
  sc += gl_FrontMaterial.specular * gl_LightSource[0].specular;
  
  // Need this instead of ftransform() for invariance
  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
  gl_FrontColor = gl_BackColor = pc;
  gl_FrontSecondaryColor = gl_BackSecondaryColor = sc;
}

