#pragma bind appdata.position = ATTR0

// Input uses vertex position and vertex normal 
struct appdata
{
	float3 vecPosition : POSITION;
	float3 vecNormal : NORMAL;
};

// Output
struct vertout
{
	float4 HPosition : POSITION;
	float4 Color : COLOR0;

}; 	 

// Entry point
vertout main(appdata IN,
	    uniform float4x4 matModelViewProj,	
		uniform float4x4 matModelViewIT,
		uniform float4x4 matModelView,
		uniform float4 materialDiffuse : DIFFUSE,
		uniform float4 materialAmbient : AMBIENT,
		uniform float4 materialSpecular : SPECULAR,
		uniform float4 materialEmissive : EMISSIVE,
		uniform float4 vecPower,
		uniform float4 vecCenter,
		uniform float4 vecBlendParams,
		uniform float4 vecLightDir,
		uniform float4 vecEye,
		uniform float4 vecTime
	    )

{
	vertout OUT;

	// Relative distance of vertexposition to outer perimeter of the ship
	float fDelta	= abs(distance(vecCenter, IN.vecPosition.xyzz))/vecBlendParams.x;

	// Alpha calculation (cloaking)
	float fAlpha	= (1.0f-fDelta) * vecBlendParams.y;
	fAlpha			= fAlpha + fDelta * vecBlendParams.z;

	// Position in homogenous coordinates
	float4 vecPos	= float4(IN.vecPosition.x,IN.vecPosition.y , IN.vecPosition.z, 1);

	// Position calculation in eye space
	vecPos	= mul(matModelViewProj, vecPos);

	// Cloaking vertex movement relative to current alpha 
	float fDist	= ((vecPos.y - vecCenter.y)+1)/2;
	vecPos.x = vecPos.x + (sin(fDist+vecTime.x)) * (1.0-fAlpha);

	// Resulting output
	OUT.HPosition = vecPos;

	// Lightning (to make the not textured model interesting)
	
	// Transform normal from model-space to view-space
    float4 vecNormal = normalize(mul(matModelViewIT, IN.vecNormal.xyzz));

	// Transform the camera location into eye space
	vecEye = mul(matModelView, vecEye);
	
    // Store normalized light vector
	float4 vecLight	= normalize(vecLightDir);

    // Calculate vecHalf angle vector     
    float4 vecHalf = normalize(vecLight + vecEye);                    

    // Calculate diffuse component
    float vecDiffuse = dot(vecNormal, vecLight);

    // calculate specular component
    float fSpecular = dot(vecNormal, vecHalf);
    fSpecular = pow(fSpecular, vecPower.x);

    // Combine ambient, diffuse and specular contributions and output final vertex color
    OUT.Color =  0.2f * materialAmbient + vecDiffuse * materialDiffuse + fSpecular * materialSpecular + materialEmissive;
	OUT.Color.w = fAlpha;

	return OUT;
} 

  

