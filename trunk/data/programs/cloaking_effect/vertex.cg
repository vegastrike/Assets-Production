#pragma bind appdata.position = ATTR0

// Input uses vertex position and vertex normal 
struct appdata : application2vertex 
{
	float3 vecPosition;
	float3 vecNormal;
};

// Output
struct vfconn : vertex2fragment 
{
	float4 HPOS;  // hardcode name
	float4 COL0;

}; 	 

// Entry point
vfconn main(appdata I,
	    uniform float4x4 matModelViewProj,	
		uniform float4x4 matModelViewIT,
		uniform float4x4 matModelView,
		uniform float4 materialDiffuse,
		uniform float4 materialAmbient,
		uniform float4 materialSpecular,
		uniform float4 materialEmissive,
		uniform float4 vecPower,
		uniform float4 vecCenter,
		uniform float4 vecBlendParams,
		uniform float4 vecLightDir,
		uniform float4 vecEye,
		uniform float4 vecTime
	    )

{
	vfconn output;

	// Relative distance of vertexposition to outer perimeter of the ship
	float fDelta	= abs(distance(vecCenter, I.vecPosition.xyzz))/vecBlendParams.x;

	// Alpha calculation (cloaking)
	float fAlpha	= (1.0f-fDelta) * vecBlendParams.y;
	fAlpha			= fAlpha + fDelta * vecBlendParams.z;

	// Position in homogenous coordinates
	float4 vecPos	= float4(I.vecPosition.x,I.vecPosition.y , I.vecPosition.z, 1);

	// Position calculation in eye space
	vecPos	= mul(matModelViewProj, vecPos);

	// Cloaking vertex movement relative to current alpha 
	float fDist	= ((vecPos.y - vecCenter.y)+1)/2;
	vecPos.x = vecPos.x + (sin(fDist+vecTime.x)) * (1.0-fAlpha);

	// Resulting output
	output.HPOS = vecPos;

	// Lightning (to make the not textured model interesting)
	
	// Transform normal from model-space to view-space
    float4 vecNormal = normalize(mul(matModelViewIT, I.vecNormal.xyzz));

	// Transform the camera location into eye space
	vecEye = mul(matModelView, vecEye);
	
    // Store normalized light vector
	float4 vecLight	= normalize(vecLightDir);

    // Calculate vecHalf angle vector     
    float4 vecHalf = normalize(vecLight + vecEye);                    

    // Calculate diffuse component
    float vecDiffuse = dot(vecNormal, vecLight);

    // calculate specular component
    float fSpecular = dot(vecNormal, vecHalf);
    fSpecular = pow(fSpecular, vecPower.x);

    // Combine ambient, diffuse and specular contributions and output final vertex color
    output.COL0 =  0.2f * materialAmbient + vecDiffuse * materialDiffuse + fSpecular * materialSpecular + materialEmissive;
	output.COL0.w = fAlpha;

	return output;
} 

  

